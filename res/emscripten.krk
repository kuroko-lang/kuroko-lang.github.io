import os
import stat
import fileio
from js import exec

let home = os.environ.get('HOME','/')

let iconColors = {
    'code': 'red', # Actually that works just fine
    'project': '#48b048', # string green
    'folder': '#e6ce6e', # builtin yellow
    'info': '#33a2e6', # keyword blue
}

let shell_commands = {}

def shellCommand(func):
    shell_commands[func.__name__] = func
    return func

def max(iterable):
    let current = None
    for i in iterable:
        if current is None or i > current:
            current = i
    return current

def colorFile(file):
    let name, result = file
    if stat.S_ISDIR(result.st_mode):
        return f'\[[34m{name}\[[0m'
    else:
        return f'{name}'

def printFileLong(file,maxLength):
    let name, result = file
    let padding = (maxLength + 2) - len(name)
    print(colorFile(file) + ' ' * padding, result.st_size)

def printFileShort(file, maxLength):
    let name, result = file
    let padding = (maxLength + 2) - len(name)
    print(colorFile(file) + ' ' * padding,end='')

@shellCommand
def ls(args):
    # Pop 'ls' from args
    args.pop(0)
    # Set up flags
    let targets = ['.']
    let human = False
    let long = False
    let showAll = False
    # Process arguments
    while args and args[0].startswith('-'):
        for c in args[0][1:]:
            if c == 'l':
                long = True
            elif c == 'h':
                human = True
            elif c == 'a':
                showAll = True
            else:
                fileio.stderr.write(f'ls: unrecognized option "{c}"\n')
        args.pop(0)
    if args: targets = args
    for directory in targets:
        if len(targets) > 1:
            print(f'Directory listing for {directory}')
        let files = {}
        for d in fileio.opendir(directory):
            let name = d['name']
            if name.startswith('.') and not showAll: continue
            # Stat that, all on the floor...
            let result = os.stat(directory + '/' + name)
            files[name] = (name, result)
        let maxLength = max([len(x) for x in files.keys()])
        if long:
            for key in sorted(files.keys()):
                printFileLong(files[key], maxLength)
        else:
            for key in sorted(files.keys()):
                printFileShort(files[key], maxLength)
            if files: print('')
        if len(targets) > 1:
            print('')

@shellCommand
def pwd(args):
    print(os.getcwd())

@shellCommand
def cd(args):
    let target = home if len(args) < 2 else args[1]
    try:
        os.chdir(target)
    except Exception as e:
        print(f"cd: {target}:", e)

@shellCommand
def uname(args):
    args.pop(0)
    let order = ['sysname','nodename','release','version','machine']
    let enabled = [0,0,0,0,0]
    while args and args[0].startswith('-'):
        for c in args[0][1:]:
            if c == 'a':
                enabled = [1,1,1,1,1]
            elif c == 's':
                enabled[0] = 1
            elif c == 'n':
                enabled[1] = 1
            elif c == 'r':
                enabled[2] = 1
            elif c == 'v':
                enabled[3] = 1
            elif c == 'm':
                enabled[4] = 1
            else:
                fileio.stderr.write(f'ls: unrecognized option "{c}"\n')
        args.pop(0)
    if not any(enabled):
        enabled[0] = 1
    let values = os.uname()
    print(*[values[order[i]] for i in range(len(order)) if enabled[i]])

@shellCommand
def help(args):
    print("This is a simple fascimile of a Unix shell.")
    print("Here are the available commands:")
    for cmd in sorted(shell_commands.keys()):
        print(" ",cmd)

@shellCommand
def cat(args):
    args.pop(0)
    if not args:
        fileio.stderr.write("cat: stdin doesn't really exist\n")
    else:
        for arg in args:
            try:
                with fileio.open(arg,'r') as f:
                    print(f.read())
            except as e:
                fileio.stderr.write(f'cat: {arg}: {e!r}\n')

@shellCommand
def mkdir(args):
    args.pop(0)
    if not args:
        fileio.stderr.write('mkdir: expected argument\n')
    else:
        os.mkdir(args.pop(0))

@shellCommand
def touch(args):
    args.pop(0)
    if not args:
        fileio.stderr.write('touch: missing file argument\n')
    else:
        with fileio.open(args[0],'w') as f:
            pass

@shellCommand
def clear(args):
    exec('document.getElementById("container").innerHTML = "";')

class FileNode(object):
    def __init__(self, path, children=[]):
        let filename = path.split('/')[-1]
        self.path  = path
        self.name  = filename
        self.color = iconColors['code'] if filename.endswith('.krk') else iconColors['project'] if filename == 'Project' else iconColors['folder'] if children else 'white'
        self.icon  = 'code' if filename.endswith('.krk') else 'package' if filename == 'Project' else 'folder' if children else 'text'
        self.children = children

def createListEntry(obj):
    let children = ('<ul>' + ''.join([createListEntry(c) for c in obj.children]) + '</ul>') if obj.children else ''
    let onclick = f'toggleDirectory(this)' if obj.children else f'openEmscriptenFile(\'{obj.path}\')'
    return f'<li><a class="file-item" ondblclick="{onclick}"><svg class="icon-sm" viewBox="0 0 24 24" style="color: {obj.color}"><use href="#icon-{obj.icon}"></use></svg> <span class="tab-title">{obj.name}</a>{children}</li>'

def setFiles(root):
    exec(f'document.getElementById("panel-files").querySelector(".panel-contents").innerHTML = `<ul>{createListEntry(root)}</ul>`;')

def discoverFiles(path):
    let out = []
    try:
        with fileio.opendir(path) as d:
            for entry in d:
                if entry['name'].startswith('.'): continue
                let filepath = path + '/' + entry['name']
                try:
                    let statResult = os.stat(filepath)
                    if stat.S_ISDIR(statResult.st_mode):
                        out.append(FileNode(filepath,discoverFiles(filepath)))
                    else:
                        out.append(FileNode(filepath))
    return out

def realFiles():
    let root = FileNode('Project',discoverFiles('/usr/local/lib/kuroko'))
    setFiles(root)

def shell_prompt():
    let cwd = os.getcwd()
    if cwd == home: cwd = '~'
    else if cwd.startswith(home + '/'): cwd = cwd.replace(home,'~',1)
    return f'{cwd} $'

def updatePrompt():
    exec(f"document.getElementById('shell-prompt').innerHTML = `{shell_prompt()}&nbsp;`")

def em_shell(s):
    print(shell_prompt(), s)
    let lex = s.strip().split(' ')
    if lex and lex[0] in shell_commands:
        try:
            shell_commands[lex[0]](lex)
        except Exception as e:
            fileio.stderr.write(f'Uncaught exception ({e!r}) occurred during execution of command.\n')
    else if lex:
        fileio.stderr.write(f'Command not found: {lex[0]}\n')
    updatePrompt()

let tabs = {} # Doesn't care about ordering.
let editorTabs = {}

class Tab():
    tabId = 0
    def __init__(self, name, content='Demo tab', icon='info', iconColor='info'):
        self.name = name
        self.content = content
        self.icon = icon
        self.iconColor = iconColors[iconColor]
        self.id = 'tab-ind-' + str(Tab.tabId)
        self.hint = name
        Tab.tabId++
        tabs[self.id] = self
    def renderTab(self):
        return f'''
          <div class="tab" id="{self.id}-tab" data-bs-toggle="tab" data-bs-target="#{self.id}" role="tab" aria-controls="{self.id}" aria-selected="false">
            <svg style="color: {self.iconColor};" class="icon-sm tab-icon" viewBox="0 0 24 24"><use href="#icon-{self.icon}"></use></svg>
            <span class="tab-title">
                {self.name}
            </span>
            <svg class="icon-sm close-button" viewBox="0 0 24 24" onclick="closeTab('{self.id}')"><use href="#icon-x"></use></svg>
            <div class="tooltiptext">{self.hint}</div>
          </div>
        '''
    def renderContent(self):
        return f'''
          <div class="tab-pane" role="tabpanel" id="{self.id}" aria-labelledby="{self.id}-tab">
            {self.content}
          </div>
        '''
    def activate(self):
        exec(f'document.getElementById("{self.id}-tab").click();')
    def realize(self):
        # Add to tab bar
        exec(f'addTab(`{self.renderTab()}`,`{self.renderContent()}`);')

class EditorTab(Tab):
    def __init__(self, path, code=''):
        super().__init__(path.split('/')[-1], icon='code', iconColor='code')
        self.path = path
        self.hint = path
        self.code = code
    def escapeCode(self):
        let escapes = {
            #'<': '&lt;',
            #'>': '&gt;',
            '\\': '\\\\',
            '`': '\\`',
        }
        return ''.join([(escapes[c] if c in escapes else c) for c in self.code])
    def renderContent(self):
        return f'''
          <div class="tab-pane has-statusbar" role="tabpanel" id="{self.id}" aria-labelledby="{self.id}-tab">
            <div id="{self.id}-editor" class="terminal-container above-statusbar"></div>
            <div class="status-bar">
              <div class="status-content">
                <svg class="icon-sm" viewBox="0 0 24 24"><use href="#icon-x-circle"></use></svg>
                <span class="status-errors">0</span>
              </div>
              <div class="status-content">
                <svg class="icon-sm" viewBox="0 0 24 24"><use href="#icon-alert-triangle"></use></svg>
                <span class="status-warnings">0</span>
              </div>
              <div class="status-content">
                <svg class="icon-sm" viewBox="0 0 24 24"><use href="#icon-info"></use></svg>
                <span class="status-info">0</span>
              </div>
              <div class="status-editor">
                Line <span class="status-line">1</span>, Column <span class="status-column">1</span>
              </div>
            </div>
          </div>
        '''
    def realize(self):
        super().realize()
        exec(f'let myNewEditor = createEditor("{self.id}-editor"); myNewEditor.setValue(`{self.escapeCode()}`,1);')

def tabClosed(tabId):
    print(f"[debug] js reports tab {tabId} has closed")
    if tabId in tabs:
        if isinstance(tabs[tabId],EditorTab) and tabs[tabId].path in editorTabs:
            del editorTabs[tabs[tabId].path]
        del tabs[tabId]

def openFile(path):
    # Is this file already open?
    if path in editorTabs:
        editorTabs[path].activate()
        return

    let contents = None
    with fileio.open(path,'r') as f:
        try:
            contents = f.read()
    if contents is not None:
        let newTab = EditorTab(path,contents)
        newTab.realize()
        newTab.activate()
        editorTabs[path] = newTab
    else:
        fileio.stderr.write(f'Error opening file "{path}"\n')

def newEditorTab(file):
    let path = '/tmp/' + file
    let newTab = EditorTab(path,'')
    newTab.realize()
    newTab.activate()
    editorTabs[path] = newTab

# Startup stuff
def __main__():
    # Disable automatic traceback dumping
    import kuroko
    kuroko.set_clean_output(True)
    # Print emscripten version info
    uname([None,'-a'])
    # Move to home directory
    os.chdir(home)
    # Populate file panel
    realFiles()
    # Update shell prompt
    updatePrompt()
    # Set terminal tab colors
    exec(f'document.getElementById("right-pane-terminal-tab").querySelector("svg").style.color = "{iconColors["project"]}";')
    exec(f'document.getElementById("right-pane-output-tab").querySelector("svg").style.color = "{iconColors["info"]}";')
    # Add a new welcome tab.
    let welcomeTab = Tab('Welcome','''
        <div class="p-3">
            <h1>Welcome!</h1>
            <p>This is the dynamically-generated welcome tab!</p>
            <div class="alert alert-warning"><b>Warning:</b> This IDE is a work in progress.</div>
        </div>''')
    welcomeTab.realize()
    welcomeTab.activate()

__main__()
